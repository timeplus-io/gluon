# coding: utf-8

"""
    Timeplus

    Welcome to the Timeplus HTTP REST API specification.  # noqa: E501

    OpenAPI spec version: v1
    Contact: support@timeplus.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class UDF(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'arguments': 'list[UDFArgument]',
        'auth_context': 'UDFAuthContext',
        'auth_method': 'str',
        'created_at': 'str',
        'created_by': 'Owner',
        'description': 'str',
        'is_aggregation': 'bool',
        'last_updated_at': 'str',
        'last_updated_by': 'Owner',
        'name': 'str',
        'return_type': 'str',
        'source': 'str',
        'type': 'str',
        'url': 'str'
    }

    attribute_map = {
        'arguments': 'arguments',
        'auth_context': 'auth_context',
        'auth_method': 'auth_method',
        'created_at': 'created_at',
        'created_by': 'created_by',
        'description': 'description',
        'is_aggregation': 'is_aggregation',
        'last_updated_at': 'last_updated_at',
        'last_updated_by': 'last_updated_by',
        'name': 'name',
        'return_type': 'return_type',
        'source': 'source',
        'type': 'type',
        'url': 'url'
    }

    def __init__(self, arguments=None, auth_context=None, auth_method=None, created_at=None, created_by=None, description=None, is_aggregation=None, last_updated_at=None, last_updated_by=None, name=None, return_type=None, source=None, type=None, url=None):  # noqa: E501
        """UDF - a model defined in Swagger"""  # noqa: E501
        self._arguments = None
        self._auth_context = None
        self._auth_method = None
        self._created_at = None
        self._created_by = None
        self._description = None
        self._is_aggregation = None
        self._last_updated_at = None
        self._last_updated_by = None
        self._name = None
        self._return_type = None
        self._source = None
        self._type = None
        self._url = None
        self.discriminator = None
        if arguments is not None:
            self.arguments = arguments
        if auth_context is not None:
            self.auth_context = auth_context
        if auth_method is not None:
            self.auth_method = auth_method
        if created_at is not None:
            self.created_at = created_at
        if created_by is not None:
            self.created_by = created_by
        if description is not None:
            self.description = description
        if is_aggregation is not None:
            self.is_aggregation = is_aggregation
        if last_updated_at is not None:
            self.last_updated_at = last_updated_at
        if last_updated_by is not None:
            self.last_updated_by = last_updated_by
        if name is not None:
            self.name = name
        if return_type is not None:
            self.return_type = return_type
        if source is not None:
            self.source = source
        if type is not None:
            self.type = type
        if url is not None:
            self.url = url

    @property
    def arguments(self):
        """Gets the arguments of this UDF.  # noqa: E501

        The input argument of the UDF   * For UDA: the number and type of arguments should be consistent with the main function of UDA.     the type should be the data types of proton not javascript types. It only supports int8/16/32/64, uint8/16/32/64,  # noqa: E501

        :return: The arguments of this UDF.  # noqa: E501
        :rtype: list[UDFArgument]
        """
        return self._arguments

    @arguments.setter
    def arguments(self, arguments):
        """Sets the arguments of this UDF.

        The input argument of the UDF   * For UDA: the number and type of arguments should be consistent with the main function of UDA.     the type should be the data types of proton not javascript types. It only supports int8/16/32/64, uint8/16/32/64,  # noqa: E501

        :param arguments: The arguments of this UDF.  # noqa: E501
        :type: list[UDFArgument]
        """

        self._arguments = arguments

    @property
    def auth_context(self):
        """Gets the auth_context of this UDF.  # noqa: E501


        :return: The auth_context of this UDF.  # noqa: E501
        :rtype: UDFAuthContext
        """
        return self._auth_context

    @auth_context.setter
    def auth_context(self, auth_context):
        """Sets the auth_context of this UDF.


        :param auth_context: The auth_context of this UDF.  # noqa: E501
        :type: UDFAuthContext
        """

        self._auth_context = auth_context

    @property
    def auth_method(self):
        """Gets the auth_method of this UDF.  # noqa: E501


        :return: The auth_method of this UDF.  # noqa: E501
        :rtype: str
        """
        return self._auth_method

    @auth_method.setter
    def auth_method(self, auth_method):
        """Sets the auth_method of this UDF.


        :param auth_method: The auth_method of this UDF.  # noqa: E501
        :type: str
        """

        self._auth_method = auth_method

    @property
    def created_at(self):
        """Gets the created_at of this UDF.  # noqa: E501


        :return: The created_at of this UDF.  # noqa: E501
        :rtype: str
        """
        return self._created_at

    @created_at.setter
    def created_at(self, created_at):
        """Sets the created_at of this UDF.


        :param created_at: The created_at of this UDF.  # noqa: E501
        :type: str
        """

        self._created_at = created_at

    @property
    def created_by(self):
        """Gets the created_by of this UDF.  # noqa: E501


        :return: The created_by of this UDF.  # noqa: E501
        :rtype: Owner
        """
        return self._created_by

    @created_by.setter
    def created_by(self, created_by):
        """Sets the created_by of this UDF.


        :param created_by: The created_by of this UDF.  # noqa: E501
        :type: Owner
        """

        self._created_by = created_by

    @property
    def description(self):
        """Gets the description of this UDF.  # noqa: E501


        :return: The description of this UDF.  # noqa: E501
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this UDF.


        :param description: The description of this UDF.  # noqa: E501
        :type: str
        """

        self._description = description

    @property
    def is_aggregation(self):
        """Gets the is_aggregation of this UDF.  # noqa: E501

        Whether it is an aggregation function. Only valid when type is 'javascript'  # noqa: E501

        :return: The is_aggregation of this UDF.  # noqa: E501
        :rtype: bool
        """
        return self._is_aggregation

    @is_aggregation.setter
    def is_aggregation(self, is_aggregation):
        """Sets the is_aggregation of this UDF.

        Whether it is an aggregation function. Only valid when type is 'javascript'  # noqa: E501

        :param is_aggregation: The is_aggregation of this UDF.  # noqa: E501
        :type: bool
        """

        self._is_aggregation = is_aggregation

    @property
    def last_updated_at(self):
        """Gets the last_updated_at of this UDF.  # noqa: E501


        :return: The last_updated_at of this UDF.  # noqa: E501
        :rtype: str
        """
        return self._last_updated_at

    @last_updated_at.setter
    def last_updated_at(self, last_updated_at):
        """Sets the last_updated_at of this UDF.


        :param last_updated_at: The last_updated_at of this UDF.  # noqa: E501
        :type: str
        """

        self._last_updated_at = last_updated_at

    @property
    def last_updated_by(self):
        """Gets the last_updated_by of this UDF.  # noqa: E501


        :return: The last_updated_by of this UDF.  # noqa: E501
        :rtype: Owner
        """
        return self._last_updated_by

    @last_updated_by.setter
    def last_updated_by(self, last_updated_by):
        """Sets the last_updated_by of this UDF.


        :param last_updated_by: The last_updated_by of this UDF.  # noqa: E501
        :type: Owner
        """

        self._last_updated_by = last_updated_by

    @property
    def name(self):
        """Gets the name of this UDF.  # noqa: E501


        :return: The name of this UDF.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this UDF.


        :param name: The name of this UDF.  # noqa: E501
        :type: str
        """

        self._name = name

    @property
    def return_type(self):
        """Gets the return_type of this UDF.  # noqa: E501

        The erturn type of the UDF   * For UDA: if it returns a single value, the return type is the corresponding data type of Timeplus.     It supports the same types of input arguments, except for datetime, it only supports DateTime64(3).  # noqa: E501

        :return: The return_type of this UDF.  # noqa: E501
        :rtype: str
        """
        return self._return_type

    @return_type.setter
    def return_type(self, return_type):
        """Sets the return_type of this UDF.

        The erturn type of the UDF   * For UDA: if it returns a single value, the return type is the corresponding data type of Timeplus.     It supports the same types of input arguments, except for datetime, it only supports DateTime64(3).  # noqa: E501

        :param return_type: The return_type of this UDF.  # noqa: E501
        :type: str
        """

        self._return_type = return_type

    @property
    def source(self):
        """Gets the source of this UDF.  # noqa: E501

        The source code of the UDA. There are functions to be defined:  * main function: with the same name as UDA. Timeplus calls this function for each input row. The main function can return two types of result: object or simple data type    - If it returns an object, the object is like {“emit”: true, “result”: …}. ‘Emit’ (boolean) property tells Timeplus whether or not the result should emit. ‘result’ is the current aggregate result, if ‘emit’ is false, the result will be ignored by Timeplus. Timeplus will convert the ‘result’ property of v8 to the data types defined when creating UDA.    - If it returns a simple data type, Timeplus considers the return data as the result to be emitted immediately. It converts the return data to the corresponding data type and Timeplus emits the aggregating result.    - Once UDA tells Timeplus to emit the data, UDA takes the full responsibility to clear the internal state, prepare and restart a new aggregating window, et al.  * state function: which returns the serialized state of all internal states of UDA in string. The UDA takes the responsibility therefore Timeplus can choose to persist the internal state of UDA for query recovery.  * init function: the input of this function is the string of serialized state of the internal states UDA. Timeplus calls this function when it wants to recover the aggregation function with the persisted internal state.  # noqa: E501

        :return: The source of this UDF.  # noqa: E501
        :rtype: str
        """
        return self._source

    @source.setter
    def source(self, source):
        """Sets the source of this UDF.

        The source code of the UDA. There are functions to be defined:  * main function: with the same name as UDA. Timeplus calls this function for each input row. The main function can return two types of result: object or simple data type    - If it returns an object, the object is like {“emit”: true, “result”: …}. ‘Emit’ (boolean) property tells Timeplus whether or not the result should emit. ‘result’ is the current aggregate result, if ‘emit’ is false, the result will be ignored by Timeplus. Timeplus will convert the ‘result’ property of v8 to the data types defined when creating UDA.    - If it returns a simple data type, Timeplus considers the return data as the result to be emitted immediately. It converts the return data to the corresponding data type and Timeplus emits the aggregating result.    - Once UDA tells Timeplus to emit the data, UDA takes the full responsibility to clear the internal state, prepare and restart a new aggregating window, et al.  * state function: which returns the serialized state of all internal states of UDA in string. The UDA takes the responsibility therefore Timeplus can choose to persist the internal state of UDA for query recovery.  * init function: the input of this function is the string of serialized state of the internal states UDA. Timeplus calls this function when it wants to recover the aggregation function with the persisted internal state.  # noqa: E501

        :param source: The source of this UDF.  # noqa: E501
        :type: str
        """

        self._source = source

    @property
    def type(self):
        """Gets the type of this UDF.  # noqa: E501

        Either `javascript` or `remote`  # noqa: E501

        :return: The type of this UDF.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this UDF.

        Either `javascript` or `remote`  # noqa: E501

        :param type: The type of this UDF.  # noqa: E501
        :type: str
        """

        self._type = type

    @property
    def url(self):
        """Gets the url of this UDF.  # noqa: E501


        :return: The url of this UDF.  # noqa: E501
        :rtype: str
        """
        return self._url

    @url.setter
    def url(self, url):
        """Sets the url of this UDF.


        :param url: The url of this UDF.  # noqa: E501
        :type: str
        """

        self._url = url

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(UDF, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, UDF):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
